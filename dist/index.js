/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./scripts/index.js":
/*!**************************!*\
  !*** ./scripts/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FiltersController)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/* ---------------------------------------------\n░░░░░░░ ░░ ░░   ░░░░░░░░ ░░░░░░░ ░░░░░░  ░░░░░░░\n▒▒      ▒▒ ▒▒      ▒▒    ▒▒      ▒▒   ▒▒ ▒▒\n▒▒▒▒▒   ▒▒ ▒▒      ▒▒    ▒▒▒▒▒   ▒▒▒▒▒▒  ▒▒▒▒▒▒▒\n▓▓      ▓▓ ▓▓      ▓▓    ▓▓      ▓▓   ▓▓      ▓▓\n██      ██ ███████ ██    ███████ ██   ██ ███████\n\nThis will act as our filtering engine. We will\npass in filters, then call apply(). an xhr\nrequest will be sent in the form of URL parameters,\nthe response will be returned and accessible via\nthe on('success', (response) => {}) method.\n\n---------------------------------------------- */\nvar FiltersController = /*#__PURE__*/function () {\n  function FiltersController() {\n    var api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n    var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, FiltersController);\n    // This will be used for out URL creation\n    this.api = {};\n    // Where we will store the filter parameters\n    this.value = {};\n    // Store the events here\n    this.events = {};\n    // Our user settings\n    this.settings = {\n      api: api\n    };\n\n    // Create a worker\n    this.worker = null;\n\n    // Store our scripts for the workers\n    this.scripts = {\n      xhr: \"\\n        self.onmessage = function (event) {\\n          const xhr = new XMLHttpRequest();\\n          const { url, headers } = event.data;\\n\\n          xhr.open('GET', url, true);\\n\\n          Object.keys(headers).forEach((key) => {\\n            xhr.setRequestHeader(key, headers[key]);\\n          });\\n\\n          xhr.onload = function () {\\n            if (xhr.status === 200) {\\n              self.postMessage({ status: 200, response: xhr.response });\\n            } else {\\n              self.postMessage({ status: xhr.status });\\n            }\\n          };\\n\\n          xhr.send();\\n        };\\n      \"\n    };\n    this.headers = Object.assign({\n      'x-requested-with': 'XMLHttpRequest'\n    }, headers);\n  }\n  _createClass(FiltersController, [{\n    key: \"set\",\n    value: function set() {\n      var parameter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (typeof parameter === 'string' || typeof parameter === 'number') {\n        // Reset the value of the parameter\n        this.value[parameter] = [];\n        this.add(parameter, value);\n      } else {\n        for (var key in parameter) {\n          if (parameter.hasOwnProperty(key)) this.set(key, parameter[key]);\n        }\n      }\n\n      // Trigger the change method\n      this.change();\n\n      // Call the set callback\n      this.callback('set', this.value);\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      var _this = this;\n      var parameter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (typeof parameter === 'string' || typeof parameter === 'number') {\n        // If we dont have this parameter yet, create it as an array\n        if (this.value[parameter] == undefined) this.value[parameter] = [];\n        if (Array.isArray(value)) {\n          value.forEach(function (value) {\n            // If the filter parameter value does not contain this value, then add it\n            if (_this.value[parameter].indexOf(value) == -1) _this.value[parameter].push(value);\n          });\n        } else {\n          // If the parameter value is not an array\n          // Simply push the value to the filter\n          if (this.value[parameter].indexOf(value) == -1) this.value[parameter].push(value);\n        }\n      } else {\n        for (var key in parameter) {\n          if (parameter.hasOwnProperty(key)) this.add(key, parameter[key]);\n        }\n      }\n\n      // Trigger the change method\n      this.change();\n\n      // Call the add callback\n      this.callback('add', this.value);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var parameter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (typeof parameter === 'string' || typeof parameter === 'number') {\n        if (this.value[parameter] && Array.isArray(value)) {\n          for (var index = 0; index < value.length; index++) {\n            console.log(value[index]);\n            this.remove(parameter, value[index]);\n          }\n        } else if (this.value[parameter] && this.value[parameter].indexOf(value) >= 0) {\n          // Remove this value from the parameter array\n          this.value[parameter].splice(this.value[parameter].indexOf(value), 1);\n\n          // If the parameter array is empty, delete it\n          if (this.value[parameter].length === 0) delete this.value[parameter];\n        } else if (this.value[parameter] && value == null) {\n          // Remove the parameter\n          delete this.value[parameter];\n        }\n      } else if (Array.isArray(parameter)) {\n        for (var _index = 0; _index < parameter.length; _index++) {\n          delete this.value[parameter[_index]];\n        }\n      } else {\n        try {\n          for (var key in parameter) {\n            if (parameter.hasOwnProperty(key)) this.remove(key, parameter[key]);\n          }\n        } catch (err) {\n          console.log(err);\n        }\n      }\n\n      // Trigger the change method\n      this.change();\n\n      // Call the remove callback\n      this.callback('remove', this.value);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // Clear all filters\n      this.value = {};\n\n      // Trigger the change method\n      this.change();\n\n      // Call the clear callback\n      this.callback('clear', this.value);\n    }\n  }, {\n    key: \"change\",\n    value: function change() {\n      this.callback('change', this.value);\n    }\n  }, {\n    key: \"apply\",\n    value: function apply() {\n      var _this2 = this;\n      // Used to begin the URL parameters\n      this.api.prefix = '?';\n      // Used to save our default api URL\n      this.api.url = this.settings.api;\n      // Used to determine if our prefix should be ? || &\n      this.api.index = this.settings.api.indexOf('?') >= 0 ? 1 : 0;\n      // This will be a more pretty URL for frontend purposes\n      this.api.segmentURL = window.location.origin + window.location.pathname;\n\n      // Generate the URL based on the current filters\n      for (var key in this.value) {\n        // Determine which prefix to use\n        this.api.prefix = this.api.index === 0 ? '?' : '&';\n\n        // If we have a value for a given parameter\n        if (this.value[key].length) {\n          // Create an api URL\n          this.api.url += \"\".concat(this.api.prefix + key, \"=\").concat(this.value[key].join(','));\n          // Create a prettier URL\n          this.api.segmentURL += \"\".concat(this.api.prefix + key, \"=\").concat(this.value[key].join(','));\n          // Add 1 to our index\n          this.api.index += 1;\n        }\n        ;\n      }\n\n      // Abort the previous request\n      if (this.worker) this.worker.terminate();\n\n      // Create a new Blob object using the worker's code\n      var blob = new Blob([this.scripts.xhr], {\n        type: 'application/javascript'\n      });\n      // Create a new URL object from the Blob\n      var script = URL.createObjectURL(blob);\n\n      // Create a new worker\n      this.worker = new Worker(script);\n\n      // Post the message to the worker\n      this.worker.postMessage({\n        url: this.api.url,\n        headers: this.headers\n      });\n\n      // On success\n      this.worker.onmessage = function (event) {\n        if (event.data.status === 200) {\n          // handle success\n          _this2.success(event.data.response);\n        } else {\n          // handle error\n          _this2.error(event.data.status);\n        }\n      };\n      this.callback('apply', {\n        url: this.api.url,\n        segmentURL: this.api.segmentURL\n      });\n    }\n  }, {\n    key: \"updateURL\",\n    value: function updateURL(url) {\n      window.history.replaceState({}, \"filters\", url || this.api.segmentURL);\n      this.callback('updateURL');\n    }\n  }, {\n    key: \"success\",\n    value: function success(response) {\n      this.callback('success', response);\n    }\n  }, {\n    key: \"error\",\n    value: function error(status) {\n      this.callback('error', status);\n    }\n  }, {\n    key: \"callback\",\n    value: function callback(type) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // run the callback functions\n      if (this.events[type]) this.events[type].forEach(function (event) {\n        return event(data);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, func) {\n      // If we loaded an event and it's not the on event and we also loaded a function\n      if (event && event != 'on' && event != 'callback' && this[event] && func && typeof func == 'function') {\n        if (this.events[event] == undefined) this.events[event] = [];\n        // Push a new event to the event array\n        this.events[event].push(func);\n      }\n    }\n  }]);\n  return FiltersController;\n}();\n\n\n//# sourceURL=webpack://@meteora-digital/filters/./scripts/index.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The require scope
/******/ var __webpack_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = {};
/******/ __webpack_modules__["./scripts/index.js"](0, __webpack_exports__, __webpack_require__);
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 
